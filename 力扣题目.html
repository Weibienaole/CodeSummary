<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
</head>

<body></body>
<script>
  function searchStrMax(s) {
    let arr = [],
      max = 0
    for (let i = 0; i < s.length; i++) {
      let index = arr.indexOf(s[i])
      if (index !== -1) {
        // 存在
        arr.splice(0, index + 1)
      }
      arr.push(s[i])
      max = Math.max(arr.length, max)
    }
    console.log(arr);
    return max
  }
  // console.log(searchStrMax('abcabcb'))
  var findMedianSortedArrays = function (nums1, nums2) {
    let arr = [...nums1, ...nums2]
    arr = arr.sort((a, b) => a - b)
    if (arr.length % 2 === 1 && arr.length > 1) {
      return arr[(arr.length - 1) / 2]
    } else if (arr.length === 1) return arr[0]
    return (arr[(arr.length - 2) / 2] + arr[arr.length / 2]) / 2
  }
  // console.log(findMedianSortedArrays([1, 2], [3,4]))

  var longestPalindrome = function (s) {
    let arr = [],
      max = 0
    for (let i = 0; i < s.length; i++) {
      if (arr.length === 0) {
        arr.push({ str: s[i], idx: i })
        continue
      }
      for (let j in arr) {
        if (arr[j].str.indexOf(s[i]) !== -1) {
          arr[j].str = s.slice(arr[j].idx, i)
          console.log(arr[j], s[i], s, i)
        } else {
          // arr.push({ str: s[i], idx: i })
        }
      }
    }
  }
  longestPalindrome('asdfgd')
  // console.log()

  /**
* @param {string} s
* @return {number}
*/
  var lengthOfLongestSubstring = function (str) {
    let idx = 0
    let filalyArr = []
    if (!str) return 0
    if (str.length === 1) return 1
    splitStrFn2()
    function splitStrFn2(index = 0) {
      let first, splitNextStr, next, splitStr
      // 当前第一位  启动下标点
      first = str[index]
      // 如果undefined，说明已达到临界值，结束递归
      if (!first) return
      // 排除第一位，拿到剩余str
      splitNextStr = str.slice(index + 1)
      // 在剩余str中拿到下一个匹配启动下标点的下标
      next = splitNextStr.indexOf(first)
      // 如果等于 -1 说明当前str有且只有一项 first filalyArr push
      if (next === -1) {
        let newAr = str.split('')
        newAr.splice(0, index)
        let sliceStr = ''
        // this.nowIdx = 0
        let b = newAr.reduce((sur, pre, idx) => {
          // console.log(sur, pre, idx, newAr);
          if (sur.indexOf(pre) === -1) {
            sliceStr = sur + pre
            this.nowIdx = idx || 1 + index
          } else {
            // console.log(sur, pre, idx);
            this.nowIdx = idx || 1 + index
            newAr.splice(idx + 1)
            return sur
          }
          return sliceStr
        })
        // console.log(b, first, 'sliceStr', this.nowIdx, index);

        filalyArr.filter(item => item === b).length === 0 && filalyArr.push(b)
        return splitStrFn2(++index)
      } else {
        // 拿到首次匹配到的str 也就是目标str -> t
        splitStr = str.slice(index, next + index + 1)
        // 如果filalyArr中已有当前匹配项,或者有重复字符，直接跳过，进行下一个
        let { bol, seleI } = isEvery(splitStr)
        if(seleI !== -1){
          console.log(bol, index, seleI);
          filalyArr.push(splitStr.slice(index, seleI + 1))
        }
        if ((filalyArr.indexOf(splitStr) !== -1) || !bol) return splitStrFn2(++index)
        filalyArr.push(splitStr)
      }
      // 已当前目标str进行下一小轮的匹配  t
      splitStrFn2(++index)
    }

    function isEvery(s) {
      let newA = [...s.split('')], seleI = -1
      let bol = newA.every((item, index) => {
        let newA1 = [...newA]
        newA1.splice(index, 1)
        if (newA1.indexOf(item) !== -1) {
          seleI = newA1.indexOf(item)
        }
        return newA1.indexOf(item) === -1
      })
      return { bol, seleI }
    }
    console.log(filalyArr, 'filalyArr', str);

    filalyArr = filalyArr.map(item => item.length)
    filalyArr = filalyArr.sort((a, b) => b - a)
    return filalyArr[0]
  };
  console.log(lengthOfLongestSubstring("zwnigfunjwz")) // au abb bacbacbb bbbbb pwwkew abb ohvhjdml jxdlnaaij zwnigfunjwz
</script>

</html>